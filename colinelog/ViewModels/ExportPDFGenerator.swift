import Foundation
import SwiftUI
#if canImport(UIKit)
import UIKit

struct ExportPDFGenerator {
    static func generate(logs: [ColinLog], userName: String = "") -> Data? {
        guard #available(iOS 16.0, *) else { return nil }
        let sorted = logs.sorted { $0.createdAt < $1.createdAt }
        let groups = Dictionary(grouping: sorted) { Calendar.current.startOfDay(for: $0.createdAt) }
        let orderedDays = groups.keys.sorted()
        // 日 → (1..n) スライス
        let slicesPerDay: [[DayPageSlice]] = orderedDays.map { day in
            paginate(day: day, logs: groups[day] ?? [])
        }
        let allSlices = slicesPerDay.flatMap { $0 }
        // スライスをページへパック
        let pages = packSlicesIntoPages(allSlices)
        let pageSize = Constants.pageSize
        let headerDateDF = DateFormatter(); headerDateDF.dateFormat = "yyyy/MM/dd"
        let pdf = UIGraphicsPDFRenderer(bounds: CGRect(origin: .zero, size: pageSize))
        return pdf.pdfData { ctx in
            for (pi, pageSlices) in pages.enumerated() {
                ctx.beginPage()
                let pageView = MultiSlicePageView(slices: pageSlices,
                                                  userName: userName,
                                                  generatedDate: headerDateDF.string(from: Date()))
                let renderer = ImageRenderer(content: pageView)
                renderer.scale = 3
                if let img = renderer.uiImage { img.draw(in: CGRect(origin: .zero, size: pageSize)) }
                // フッター
                drawFooter(pageIndex: pi + 1, totalSize: pageSize)
            }
        }
    }
}

// MARK: - Footer
private func drawFooter(pageIndex: Int, totalSize: CGSize) {
    let left = "Generated by コリンログ" as NSString
    left.draw(at: CGPoint(x: 40, y: totalSize.height - 22),
              withAttributes: [.font: UIFont.systemFont(ofSize: 8), .foregroundColor: UIColor.gray])
    let p = "p.\(pageIndex)" as NSString
    let attr: [NSAttributedString.Key: Any] = [.font: UIFont.systemFont(ofSize: 8), .foregroundColor: UIColor.gray]
    let w = p.size(withAttributes: attr).width
    p.draw(at: CGPoint(x: totalSize.width - 40 - w, y: totalSize.height - 22), withAttributes: attr)
}

// MARK: - 定数
private enum Constants {
    static let pageSize = CGSize(width: 595.2, height: 841.8)
    static let headerHeight: CGFloat = 72
    static let dayHeaderHeight: CGFloat = 20
    static let timelineHeight: CGFloat = 110
    static let footerHeight: CGFloat = 30
    static let horizontalMargin: CGFloat = 40
    static let columnGap: CGFloat = 20
    static let interCardSpacing: CGFloat = 10
    static let topSpacingFirstSlice: CGFloat = 14
    static let interSliceSpacing: CGFloat = 28
}

// MARK: - スライスモデル (1日内の左/右列 + 高さメタ)
private struct DayPageSlice: Identifiable {
    let id = UUID()
    let day: Date
    let leftLogs: [ColinLog]
    let rightLogs: [ColinLog]
    let pageIndexInDay: Int
    let pageCountInDay: Int
    // 列高さ(推定: 最終末尾余白除去後)
    let leftHeight: CGFloat
    let rightHeight: CGFloat
    // スライス本体高さ(ヘッダー除く、ページ内配置時の純粋高さ)
    let baseHeight: CGFloat
}

// MARK: - ページング(1日→スライス列)
private func paginate(day: Date, logs: [ColinLog]) -> [DayPageSlice] {
    // 新アルゴリズム: 1) 全残ログ高さ見積 2) 理想半分で左/右に分割 3) 右オーバーなら前で確定し次スライス
    if logs.isEmpty {
        let h: CGFloat = sliceBaseHeight(columnMax: 0)
        return [DayPageSlice(day: day, leftLogs: [], rightLogs: [], pageIndexInDay: 0, pageCountInDay: 1, leftHeight: 0, rightHeight: 0, baseHeight: h)]
    }
    let usable = Constants.pageSize.height - Constants.headerHeight - Constants.topSpacingFirstSlice - Constants.footerHeight
    let columnLimit = usable // 1列あたり最大
    // 高さ計算
    func cardHeight(_ log: ColinLog) -> CGFloat {
        let base: CGFloat = 8 + 12 + 4 + 8
        var lines: [String] = []
        if log.kind == .symptom {
            lines.append("原因: \(log.triggerDescription)")
            lines.append("対応: \(log.responseDescription)")
            lines.append("発汗: \(log.sweating.label)")
            if let d = log.detail { lines.append(contentsOf: d.split(separator: "\n").map(String.init)) }
        } else if let d = log.detail { lines.append(contentsOf: d.split(separator: "\n").map(String.init)) }
        let bodyFont = UIFont.systemFont(ofSize: 9.5)
        let lineH = ceil(bodyFont.lineHeight)
        let bodyH = CGFloat(lines.count) * (lineH + 2) - (lines.isEmpty ? 2 : 2)
        return max(46, base + max(0, bodyH))
    }
    func columnUsedHeight(_ logs: [ColinLog]) -> CGFloat { guard !logs.isEmpty else { return 0 }; return logs.reduce(0){$0+cardHeight($1)} + CGFloat(logs.count-1)*Constants.interCardSpacing }

    var slices: [DayPageSlice] = []
    var remaining = logs
    while !remaining.isEmpty {
        // 1スライス候補: 残り全体で理想分割
        let heights = remaining.map(cardHeight)
        let totalHeight = heights.reduce(0,+) + CGFloat(max(remaining.count-1,0))*Constants.interCardSpacing
        // 左列しきい値: 半分 + マージン (大きめログでも右列開始が遅れすぎないよう 24pt)
        let leftThreshold = min(columnLimit, (totalHeight / 2.0) + 24)
        var left: [ColinLog] = []
        var right: [ColinLog] = []
        var leftAccum: CGFloat = 0
        for (idx, log) in remaining.enumerated() {
            let h = heights[idx]
            let spacing = left.isEmpty ? 0 : Constants.interCardSpacing
            if left.isEmpty || (leftAccum + spacing + h) <= leftThreshold {
                // まだ左に入る
                left.append(log)
                leftAccum += spacing + h
            } else {
                right = Array(remaining[idx...])
                break
            }
        }
        if right.isEmpty { // 全部左に入った → バランスのため後半を右へ一部移動
            if left.count > 1 {
                // 後半 1/3 を右へ移動
                let moveStart = left.count * 2 / 3
                right = Array(left[moveStart...])
                left = Array(left[..<moveStart])
            }
        }
        // 右列高さ検査 (オーバーなら左末尾から右へ先送りしつつ調整)
        func adjustBalance() {
            var changed = true
            while changed {
                changed = false
                let lh = columnUsedHeight(left)
                let rh = columnUsedHeight(right)
                // 右超過→左へ戻す
                if rh > columnLimit, let first = right.first {
                    left.append(first)
                    right.removeFirst()
                    changed = true
                    continue
                }
                // 左がかなり高い場合、末尾を右へ移動(右に余裕あり)
                if lh - rh > 120, let last = left.last {
                    let lastH = cardHeight(last) + (right.isEmpty ? 0 : Constants.interCardSpacing)
                    if rh + lastH <= columnLimit {
                        right.insert(last, at: 0)
                        left.removeLast()
                        changed = true
                    }
                }
            }
        }
        adjustBalance()
        let leftHeightUsed = columnUsedHeight(left)
        let rightHeightUsed = columnUsedHeight(right)
        let sliceHeight = sliceBaseHeight(columnMax: max(leftHeightUsed, rightHeightUsed))
        let cal = Calendar.current
        let sliceDayBase = left.first?.createdAt ?? remaining.first!.createdAt
        let sliceDay = cal.startOfDay(for: sliceDayBase)
        slices.append(DayPageSlice(day: sliceDay,
                                   leftLogs: left,
                                   rightLogs: right,
                                   pageIndexInDay: slices.count,
                                   pageCountInDay: 0,
                                   leftHeight: leftHeightUsed,
                                   rightHeight: rightHeightUsed,
                                   baseHeight: sliceHeight))
        // 残り更新
        remaining.removeFirst(left.count + right.count)
    }
    // pageCountInDay 設定 (ここでは1日=1スライス or 複数だが同日) → 日毎に再計算
    let grouped = Dictionary(grouping: slices) { $0.day }
    var result: [DayPageSlice] = []
    for daySlices in grouped.values { let total = daySlices.count; for (i,s) in daySlices.enumerated() { result.append(DayPageSlice(day: s.day, leftLogs: s.leftLogs, rightLogs: s.rightLogs, pageIndexInDay: i, pageCountInDay: total, leftHeight: s.leftHeight, rightHeight: s.rightHeight, baseHeight: s.baseHeight)) } }
    // 元の順序で返却
    return result.sorted { $0.leftLogs.first?.createdAt ?? $0.day < $1.leftLogs.first?.createdAt ?? $1.day }
}

// スライス本体高さ見積り(ヘッダ含まず)
private func sliceBaseHeight(columnMax: CGFloat) -> CGFloat {
    // dayHeader paddingTop4 + dayHeaderHeight20 + spacing14 + timeline110 + spacing14 + columnMax
    return 4 + Constants.dayHeaderHeight + 14 + Constants.timelineHeight + 14 + columnMax
}

// MARK: - スライス→ページ Packing
private func packSlicesIntoPages(_ slices: [DayPageSlice]) -> [[DayPageSlice]] {
    var pages: [[DayPageSlice]] = []
    var current: [DayPageSlice] = []
    var currentHeight: CGFloat = 0
    let available = Constants.pageSize.height - Constants.headerHeight - Constants.footerHeight - Constants.topSpacingFirstSlice
    for slice in slices {
        let needed = slice.baseHeight + (current.isEmpty ? 0 : Constants.interSliceSpacing)
        if current.isEmpty {
            // 単独でも溢れるならそのまま1ページ
            if needed <= available { current.append(slice); currentHeight = needed }
            else { pages.append([slice]) } // 極端に高さがある場合(ほぼ無い想定)
            continue
        }
        if currentHeight + needed <= available {
            current.append(slice); currentHeight += needed
        } else {
            pages.append(current); current = [slice]; currentHeight = slice.baseHeight
        }
    }
    if !current.isEmpty { pages.append(current) }
    return pages
}

// MARK: - ページ View
@available(iOS 16.0, *)
private struct MultiSlicePageView: View {
    let slices: [DayPageSlice]
    let userName: String
    let generatedDate: String
    var body: some View {
        ZStack(alignment: .topLeading) {
            Color.white
            VStack(alignment: .leading, spacing: 0) {
                header
                VStack(alignment: .leading, spacing: Constants.interSliceSpacing) {
                    ForEach(slices) { SliceContentView(slice: $0) }
                }
                .padding(.top, Constants.topSpacingFirstSlice)
                Spacer(minLength: 0)
            }
            .padding(.horizontal, Constants.horizontalMargin)
            .padding(.top, 20)
        }
        .frame(width: Constants.pageSize.width, height: Constants.pageSize.height)
    }
    private var header: some View {
        HStack(alignment: .top, spacing: 12) {
            Image("ReportIcon").resizable().frame(width: 32, height: 32)
            VStack(alignment: .leading, spacing: 4) {
                Text("コリン性蕁麻疹 症状レポート (生成日: \(generatedDate))")
                    .font(.system(size: 13, weight: .bold))
                if !userName.isEmpty { Text(userName).font(.system(size: 10)).foregroundColor(.gray) }
            }
            Spacer()
        }
        .overlay(alignment: .bottom) { Divider().offset(y: 8) }
    }
}

// MARK: - スライス本体表示
@available(iOS 16.0, *)
private struct SliceContentView: View {
    let slice: DayPageSlice
    var body: some View {
        VStack(alignment: .leading, spacing: 14) {
            Text(slice.day.stringYMDWithWeek())
                .font(.system(size: 12, weight: .bold))
                .padding(.top, 4)
            TimelineBarView(logs: slice.leftLogs + slice.rightLogs)
                .frame(height: Constants.timelineHeight)
                .clipShape(RoundedRectangle(cornerRadius: 14))
            ColumnsView(left: slice.leftLogs, right: slice.rightLogs)
        }
    }
}

// MARK: - Columns
@available(iOS 16.0, *)
private struct ColumnsView: View {
    let left: [ColinLog]; let right: [ColinLog]
    var body: some View {
        HStack(alignment: .top, spacing: Constants.columnGap) {
            VStack(alignment: .leading, spacing: Constants.interCardSpacing) {
                ForEach(left) { CardView(log: $0) }
            }
            VStack(alignment: .leading, spacing: Constants.interCardSpacing) {
                ForEach(right) { CardView(log: $0) }
            }
        }
    }
}

// MARK: - タイムライン(棒高さ=重症度)
@available(iOS 16.0, *)
private struct TimelineBarView: View {
    let logs: [ColinLog]
    var body: some View {
        ZStack(alignment: .topLeading) {
            RoundedRectangle(cornerRadius: 14)
                .fill(Color(.systemGray6))
                .overlay(RoundedRectangle(cornerRadius: 14)
                            .stroke(Color(.systemGray4), lineWidth: 0.8))
            GeometryReader { geo in
                let width = geo.size.width - 28
                let height = geo.size.height - 36
                let x0: CGFloat = 14
                let y0: CGFloat = 18
                Path { p in
                    p.move(to: CGPoint(x: x0, y: y0 + height))
                    p.addLine(to: CGPoint(x: x0 + width, y: y0 + height))
                }.stroke(Color(.systemGray3), lineWidth: 0.8)
                ForEach([0,6,12,18,24], id: \.self) { h in
                    let x = x0 + CGFloat(h)/24 * width
                    Path { p in
                        p.move(to: CGPoint(x: x, y: y0 + height - 4))
                        p.addLine(to: CGPoint(x: x, y: y0 + height + 4))
                    }.stroke(Color(.systemGray3), lineWidth: 0.6)
                    Text(String(format: "%02d:00", h))
                        .font(.system(size: 7.5))
                        .foregroundColor(.gray)
                        .position(x: x - 6, y: y0 + height + 10)
                }
                let symptoms = logs.filter { $0.kind == .symptom }
                if symptoms.isEmpty {
                    Text("症状ログなし")
                        .font(.system(size: 10))
                        .foregroundColor(.gray)
                        .position(x: geo.size.width/2, y: geo.size.height/2)
                } else {
                    ForEach(symptoms) { log in
                        let comps = Calendar.current.dateComponents([.hour,.minute], from: log.createdAt)
                        let mins = (comps.hour ?? 0) * 60 + (comps.minute ?? 0)
                        let x = x0 + CGFloat(mins) / (24*60) * width
                        let maxBar: CGFloat = 60
                        let barH = maxBar * CGFloat(log.severity.rawValue) / 5.0
                        severityColor(level: log.severity.rawValue)
                            .frame(width: 6, height: barH)
                            .clipShape(RoundedRectangle(cornerRadius: 3))
                            .position(x: x, y: y0 + height - barH/2)
                    }
                }
            }
        }
    }
}

// MARK: - カード
@available(iOS 16.0, *)
private struct CardView: View {
    let log: ColinLog
    let bodyFont = Font.system(size: 9.5)
    var body: some View {
        HStack(alignment: .top, spacing: 8) {
            badge
            VStack(alignment: .leading, spacing: 4) {
                Text(log.createdAt.colinTimeHHmm)
                    .font(.system(size: 10, weight: .bold))
                ForEach(lines(), id: \.self) { line in
                    Text(line)
                        .font(bodyFont)
                        .fixedSize(horizontal: false, vertical: true)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .padding(.vertical, 4)
    }
    private func lines() -> [String] {
        var out: [String] = []
        if log.kind == .symptom {
            out.append("原因: \(log.triggerDescription)")
            out.append("対応: \(log.responseDescription)")
            out.append("発汗: \(log.sweating.label)")
            if let d = log.detail, !d.isEmpty { out.append(contentsOf: d.split(separator: "\n").map(String.init)) }
        } else if let d = log.detail, !d.isEmpty { out.append(contentsOf: d.split(separator: "\n").map(String.init)) }
        return out
    }
    @ViewBuilder private var badge: some View {
        if log.kind == .memo {
            ZStack { RoundedRectangle(cornerRadius: 8).fill(Color(.systemGray4)); Text("メモ").font(.system(size: 9)).foregroundColor(.white) }
                .frame(width: 46, height: 32)
        } else {
            ZStack(alignment: .topLeading) {
                RoundedRectangle(cornerRadius: 8).fill(severityColor(level: log.severity.rawValue))
                VStack(alignment: .leading, spacing: 0) {
                    Text("\(log.severity.rawValue)")
                        .font(.system(size: 13, weight: .bold))
                        .foregroundColor(.white)
                        .padding(.top, 4)
                        .padding(.leading, 12)
                    Text(log.severity.label)
                        .font(.system(size: 9))
                        .foregroundColor(.white)
                        .padding(.leading, 6)
                        .padding(.top, -2)
                }
            }
            .frame(width: 46, height: 32)
        }
    }
}

// MARK: - 共通
private func severityColor(level: Int) -> Color {
    switch level {
    case 1: return Color(.systemBlue)
    case 2: return Color(.systemGreen)
    case 3: return Color(.systemYellow)
    case 4: return Color(.systemOrange)
    case 5: return Color(.systemRed)
    default: return Color(.systemGray)
    }
}
private extension Date {
    func stringYMDWithWeek() -> String { let df = DateFormatter(); df.dateFormat = "yyyy/MM/dd (E)"; return df.string(from: self) }
    func stringYMD() -> String { let df = DateFormatter(); df.dateFormat = "yyyy/MM/dd"; return df.string(from: self) }
}
#endif
